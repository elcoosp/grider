use image::*;
use imageproc::{contrast::adaptive_threshold, drawing::draw_line_segment_mut};

/// Represents the kind of a line (row or column).
///
/// A line can be either [`LineKind::Empty`] (fully white) or [`LineKind::Full`] (contains non-white pixels).
#[derive(Debug, PartialEq, Clone)]
enum LineKind {
    Empty,
    Full,
}

/// Represents a row in the grid.
///
/// A row is defined by its starting y-coordinate (`y`), height (`height`), and [`LineKind`].
#[derive(Debug)]
struct Row {
    y: u32,
    height: u32,
    kind: LineKind,
}

/// Represents a column in the grid.
///
/// A column is defined by its starting x-coordinate (`x`), width (`width`), and [`LineKind`].
#[derive(Debug)]
struct Column {
    x: u32,
    width: u32,
    kind: LineKind,
}

/// Represents the grid composed of [`Row`]s and [`Column`]s.
///
/// The grid is generated by processing an image and grouping consecutive rows and columns
/// based on their [`LineKind`].
#[derive(Debug)]
struct Grid {
    rows: Vec<Row>,
    columns: Vec<Column>,
}

/// Trait to create lines (rows or columns).
///
/// This trait is implemented for both [`Row`] and [`Column`] to allow generic processing of lines.
trait LineTrait {
    fn new(start: u32, length: u32, kind: LineKind) -> Self;
}

impl LineTrait for Row {
    fn new(start: u32, length: u32, kind: LineKind) -> Self {
        Row {
            y: start,
            height: length,
            kind,
        }
    }
}

impl LineTrait for Column {
    fn new(start: u32, length: u32, kind: LineKind) -> Self {
        Column {
            x: start,
            width: length,
            kind,
        }
    }
}

/// Checks if a row is empty (all pixels are white).
///
/// # Arguments
/// * `img` - The grayscale image to check.
/// * `y` - The y-coordinate of the row.
/// * `width` - The width of the image.
///
/// # Returns
/// `true` if the row is empty (fully white), otherwise `false`.
fn is_row_empty(img: &GrayImage, y: u32, width: u32) -> bool {
    (0..width).all(|x| img.get_pixel(x, y).channels()[0] == 255)
}

/// Checks if a column is empty (all pixels are white).
///
/// # Arguments
/// * `img` - The grayscale image to check.
/// * `x` - The x-coordinate of the column.
/// * `height` - The height of the image.
///
/// # Returns
/// `true` if the column is empty (fully white), otherwise `false`.
fn is_column_empty(img: &GrayImage, x: u32, height: u32) -> bool {
    (0..height).all(|y| img.get_pixel(x, y).channels()[0] == 255)
}
/// Processes lines (rows or columns) and groups them by their [`LineKind`].
///
/// This function merges adjacent lines of the same kind and uses a dynamic threshold
/// to ignore lines smaller than a fraction of the average size.
///
/// # Arguments
/// * `img` - The grayscale image to process.
/// * `length` - The length of the lines (height for rows, width for columns).
/// * `is_empty` - A function to check if a line is empty.
///
/// # Returns
/// A vector of lines grouped by their [`LineKind`].
fn process_lines<T>(img: &GrayImage, length: u32, is_empty: impl Fn(u32) -> bool) -> Vec<T>
where
    T: LineTrait,
{
    let mut lines = Vec::new();
    let mut current_start = 0;
    let mut current_kind = if is_empty(0) {
        LineKind::Empty
    } else {
        LineKind::Full
    };
    let mut current_length = 1;

    // First pass: Collect all lines without grouping
    let mut all_lines = Vec::new();
    for i in 1..length {
        let new_kind = if is_empty(i) {
            LineKind::Empty
        } else {
            LineKind::Full
        };
        if new_kind == current_kind {
            current_length += 1;
        } else {
            all_lines.push((current_start, current_length, current_kind.clone()));
            current_start = i;
            current_kind = new_kind;
            current_length = 1;
        }
    }
    // Push the last line
    all_lines.push((current_start, current_length, current_kind));

    // Calculate the average size of all lines
    let total_size: u32 = all_lines.iter().map(|&(_, length, _)| length).sum();
    let average_size = if all_lines.is_empty() {
        0
    } else {
        total_size / all_lines.len() as u32
    };
    println!("Average size: {}", average_size);

    // Use 80% of the average size as the threshold to merge more lines
    let threshold = (average_size * 8) / 10;

    // Second pass: Merge lines smaller than the threshold and of the same kind
    let mut merged_lines = Vec::new();
    let mut current_merged_start = all_lines[0].0;
    let mut current_merged_length = all_lines[0].1;
    let mut current_merged_kind = all_lines[0].2.clone();

    for (start, length, kind) in &all_lines[1..] {
        if current_merged_length < threshold || *length < threshold {
            // Merge with the previous line if they are of the same kind and either is smaller than the threshold
            current_merged_length += length;
            println!(
                "Merging line: start={}, length={}, kind={:?}",
                start, length, kind
            );
        } else {
            // Push the merged line
            merged_lines.push((
                current_merged_start,
                current_merged_length,
                current_merged_kind.clone(),
            ));
            current_merged_start = *start;
            current_merged_length = *length;
            current_merged_kind = kind.clone();
        }
    }
    // Push the last merged line
    merged_lines.push((
        current_merged_start,
        current_merged_length,
        current_merged_kind,
    ));

    println!(
        "Lines before merging: {}, after merging: {}",
        all_lines.len(),
        merged_lines.len()
    );

    // Convert merged lines to the appropriate type
    for (start, length, kind) in merged_lines {
        lines.push(T::new(start, length, kind));
    }

    lines
}
/// Quickselect algorithm to find the k-th smallest element in a vector.
fn quickselect(arr: &mut [u32], k: usize) -> u32 {
    let pivot_index = partition(arr);
    if pivot_index == k {
        arr[pivot_index]
    } else if pivot_index < k {
        quickselect(&mut arr[pivot_index + 1..], k - pivot_index - 1)
    } else {
        quickselect(&mut arr[..pivot_index], k)
    }
}

/// Partition function for quickselect.
fn partition(arr: &mut [u32]) -> usize {
    let pivot = arr[arr.len() / 2];
    let (mut i, mut j) = (0, arr.len() - 1);
    while i <= j {
        while arr[i] < pivot {
            i += 1;
        }
        while arr[j] > pivot {
            j -= 1;
        }
        if i <= j {
            arr.swap(i, j);
            i += 1;
            j -= 1;
        }
    }
    j + 1
}

/// Processes the image and generates the [`Grid`].
///
/// This function converts the image to grayscale, applies adaptive thresholding,
/// and processes it to generate the [`Grid`] of [`Row`]s and [`Column`]s.
///
/// # Arguments
/// * `image` - The input image to process.
///
/// # Returns
/// A [`Grid`] representing the rows and columns of the image.
fn process_image(image: DynamicImage) -> Grid {
    // Convert the image to grayscale
    let img = image.to_luma8();

    // Apply adaptive thresholding
    let binarized_img = adaptive_threshold(&img, 12); // Adjust the radius as needed

    // Process rows and columns
    let (width, height) = binarized_img.dimensions();
    let rows = process_lines(&binarized_img, height, |y| {
        is_row_empty(&binarized_img, y, width)
    });
    let columns = process_lines(&binarized_img, width, |x| {
        is_column_empty(&binarized_img, x, height)
    });

    // Create the Grid
    Grid { rows, columns }
}

/// Debug module for visualizing the grid on the image.
mod debug {
    use super::*;

    /// Saves the image with grid lines for debugging.
    ///
    /// This function draws horizontal lines for [`Row`]s and vertical lines for [`Column`]s
    /// on the image and saves it to the specified path.
    ///
    /// # Arguments
    /// * `image` - The input image.
    /// * `grid` - The [`Grid`] to visualize.
    /// * `output_path` - The path to save the output image.
    pub fn save_image_with_grid(image: &DynamicImage, grid: &Grid, output_path: &str) {
        // Convert the image to RGBA for drawing
        let mut rgba_img = image.to_rgba8();
        let (w, h) = (rgba_img.width() as f32, rgba_img.height() as f32);

        // Draw horizontal lines for rows
        for row in &grid.rows {
            let y = row.y + row.height;
            draw_line_segment_mut(
                &mut rgba_img,
                (0.0, y as f32),
                (w, y as f32),
                Rgba([255, 0, 0, 255]), // Red color for rows
            );
        }

        // Draw vertical lines for columns
        for column in &grid.columns {
            let x = column.x + column.width;
            draw_line_segment_mut(
                &mut rgba_img,
                (x as f32, 0.0),
                (x as f32, h),
                Rgba([0, 0, 255, 255]), // Blue color for columns
            );
        }

        // Save the image with grid lines
        rgba_img.save(output_path).unwrap();
        println!("Image with grid lines saved to {}", output_path);
    }
}

/// Unit tests for the grid generation logic.
#[cfg(test)]
mod tests {
    use super::*;

    /// Tests the `is_row_empty` function.
    #[test]
    fn test_is_row_empty() {
        let img =
            GrayImage::from_raw(3, 3, vec![255, 255, 255, 255, 0, 255, 255, 255, 255]).unwrap();
        assert!(is_row_empty(&img, 0, 3));
        assert!(!is_row_empty(&img, 1, 3));
        assert!(is_row_empty(&img, 2, 3));
    }

    /// Tests the `is_column_empty` function.
    #[test]
    fn test_is_column_empty() {
        let img =
            GrayImage::from_raw(3, 3, vec![255, 255, 255, 255, 0, 255, 255, 255, 255]).unwrap();
        assert!(is_column_empty(&img, 0, 3));
        assert!(!is_column_empty(&img, 1, 3));
        assert!(is_column_empty(&img, 2, 3));
    }

    /// Tests the `process_lines` function.
    #[test]
    fn test_process_lines() {
        let img =
            GrayImage::from_raw(3, 3, vec![255, 255, 255, 255, 0, 255, 255, 255, 255]).unwrap();
        let rows: Vec<Row> = process_lines(&img, 3, |y| is_row_empty(&img, y, 3));
        assert_eq!(rows.len(), 2);
        assert_eq!(rows[0].height, 1);
        assert_eq!(rows[1].height, 2);
    }
}

fn main() {
    // Replace with the path to your image file
    let image_path = "tests/13.png";

    // Open the image file
    match image::open(image_path) {
        Ok(img) => {
            // Process the image
            let grid = process_image(img.clone());

            // Print the grid (or use it as needed)
            println!("{:?}", grid);

            // Save the image with grid lines for debugging
            debug::save_image_with_grid(&img, &grid, "output_with_grid.png");
        }
        Err(e) => {
            eprintln!("Failed to open image: {}", e);
        }
    }
}
